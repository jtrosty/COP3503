
import controlP5.*;
ControlP5 cp5;

int width = 1600;
int height = 1000;

float camBounds = 60;
CameraControl camControl;
PVector zeroPoint = new PVector(0,0,0);
Terrain terrain;


void setup() {
    size(1600, 1000, P3D);
    cp5 = new ControlP5(this);
    //cp5.addSlider("cameraX", -camBounds, camBounds).setPosition(20,30);
    //cp5.addSlider("cameraY", -camBounds, camBounds).setPosition(20,50);
    //cp5.addSlider("cameraZ", -camBounds, camBounds).setPosition(20,70);
    //wiredMonster.shape = loadShape("monster.obj");
    //halfMonster.shape = loadShape("monster.obj");
    camControl = new CameraControl();
    camControl.AddLookAtTarget(new PVector(0, 0, 0));
}


void draw() {
    background(200);
    perspective(radians(50.0f), width / (float) height, 0.1, 1000);
    camControl.Update();
    DrawGridLines();
    terrain.generateIndexList();

    
    perspective();
    camera();
}

// Controls

void mouseWheel(MouseEvent event) {
    camControl.Zoom(event.getCount());
}
void keyPressed() {
    //camControl.CycleTarget();
}

class Terrain {
    int rows = 1;
    int cols = 1;
    int gridSize = 10;
    ArrayList<PVector> vertesList;
    ArrayList<Integer> indexData;


    void generateIndexList() {
        int numOfTriangles = rows * cols * 2;
        int verticesInRow = cols + 1;
        for (int j = 0; j < rows; j++) {
            for (int i = 0; i < cols; i++) {
                // Form both triangles for a square
                // Triangle 1
                indexData.add(j + i);
                indexData.add(j + i + 1);
                indexData.add(j + i + verticesInRow);
                // Triangle 2 
                indexData.add(j + i + 1);
                indexData.add(j + i + verticesInRow + 1);
                indexData.add(j + i + verticesInRow);
            }
        }

    }
}


class CameraControl {

    ArrayList<PVector> targets = new ArrayList<PVector>();
    float theta = PI / 4.0;
    float phi = PI / 4.0;
    float distance = 100;
    float cameraX = 0;
    float cameraY = 0;
    float cameraZ = 0;
    float deltaX = 0;
    float deltaY = 0;
    float minZoom = 10.0;
    float maxZoom = 200.0;
    float scaleMouseControl = 0.005;
    float increment = PI / 180.0;
    PVector currentTarget;
    int currIndex = 0;
    CameraControl() {
        targets.add(zeroPoint);
        currentTarget = zeroPoint;
    }

    void Update() {
        camera( cameraX, cameraY, cameraZ,
                currentTarget.x, currentTarget.y, currentTarget.z,
                0, -1, 0);
        if (cp5.isMouseOver()) {
          return;
        }
        else if (mousePressed == true) {
          deltaX = (mouseX - pmouseX) * scaleMouseControl;
          deltaY = (mouseY - pmouseY) * scaleMouseControl;
          phi = phi + deltaX;
          theta = theta + deltaY;
          cameraX = currentTarget.x + distance * cos(phi) * sin(theta);
          cameraY = currentTarget.y + distance * cos(theta);
          cameraZ = currentTarget.z + distance * sin(theta) * sin(phi);
          
          //theta = (mouseY / 360) % (PI);
          camera( cameraX, cameraY, cameraZ,
                currentTarget.x, currentTarget.y, currentTarget.z,
                0, -1, 0);
        }
        else {
          camera( cameraX, cameraY, cameraZ,
                currentTarget.x, currentTarget.y, currentTarget.z,
                0, -1, 0);
        }
          
    }

    void AddLookAtTarget(PVector v1) {
        targets.add(v1);
    }

    void CycleTarget() {
        if (currIndex < targets.size() - 1) {
            currIndex++;
        }
        else {
            currIndex = 0;
        }
        currentTarget = targets.get(currIndex);
    }

    void Zoom(float zoom) {
        distance += zoom * 6;
        if (distance < minZoom) distance = minZoom;
        if (distance > maxZoom) distance = maxZoom;
    }
}

void DrawGridLines() {
    int numOfLines = 20;
    float startX = -100;
    float increment = 10;

    strokeWeight(1);
    stroke(50);
    for (int i = 0; i <= numOfLines; i++) {
        line( startX + (i * increment), 0.0, startX, startX + (increment * i), 0.0, -startX);
        line( startX, 0.0, startX + (i * increment), -startX, 0.0, startX + (increment * i));
        //line(-500, -500 + (i * 100), 500, 0, 0);
    }
    strokeWeight(5);
    stroke(255, 0, 0);
    line(startX, 0, 0, -startX, 0, 0);
    stroke(0, 255, 0);
    line(0, startX, 0, 0,-startX, 0);
    stroke(0, 0, 255);
    line(0, 0, startX, 0, 0, -startX);

    strokeWeight(1);
}
